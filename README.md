# 유민혁 학번 202130419

## 4월 12일 강의
#### 내용정리 
static 메소드는 오직 static 멤버만 접근 가능
-객체가 생성되지 않은 상화에서도 static 메소드는 실행될 수 있기 떄문에 ,non-static 멤버 활용 불가
-non-static 메소드는 static 멤버 활용 가능 
static 메소드는 this 사용 불가
- static 메소드는 객체없이도 사용 가능하므로 this 레퍼런스 사용할수 없음
상속 선언 
extends 키워드로 선언 -부모 클래스를 물려받아 확장한다는 의미
부모 클래서 -> 슈퍼클래스
자식 클래스 -> 서브 클래스
서브 클래스 객체의 모양
- 슈퍼 클래스 객체와 서브클래스의 객체는 별개
- 서브 클래스 객체는 슈퍼 클래스 멤버 포함
자바의 상속의 특징
클래스 다중 상속 불허
-C++ 은 다중상속 클래스가 가능 

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버 - 서브 클래스에서 접근 할수 없음
슈퍼 클래스의 디폴트 멤버
- 서브 클래스가 동일한 패키지에 있을떄 접근간으
슈퍼 클래스의 public 멤버
-서브 클래스는 항상 접근 가능
슈퍼클래스의 protected 상속
 protected 멤버에 대한 접근
 -같은 패키지의 모든 클래스에게 허용
 - 상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용
 서브 클래스의 개게가 생성될 때
 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
 슈퍼 클래스와 서브 클래스
 - 각각 여러 개의 생성자 작성 가능
 서브 클래스의 객체가 생성될 때
 - 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 ㅂㅇ식
 1 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
 2 컴파일러가 기본 생성자 선택
 super() 
 -서브 클래스에서 명시적으로 슈퍼클래스 호출
 

업캐스팅의 개념
업캐스팅은 하위 클래스를 상위 클래스 타입으로 변환하는 것. 상속 계층 구조에서 자주 사용되며, 다형성을 활용하여 다양한 객체를 동일한 인터페이스로 다룰 수 있게 컴파일 타임 다형성을 제공하여 유연하고 확장 가능한 코드를 작성하는 데 도움이 됨

업캐스팅
서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가르키게 되는 현상

다운캐스팅의 개념
다운캐스팅은 상위 클래스 타입을 하위 클래스 타입으로 변환하는 것. 업캐스팅과 반대되며 명시적인 형 변환을 필요로, 주로 상위 클래스로 선언된 객체를 실제로는 하위 클래스로 사용해야 할 때 사용되며 타입 안전성을 보장하기 위해 주의해서 사용해야 함

다운캐스팅
슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
업캐스팅된 것을 다시 월래대로 되돌리는 것
반드시 명시적 타입 변환 지정

[ 업캐스팅 레퍼런스로 객체 구별?? ]
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
    --> 슈퍼 클래스에서 여러 서브 클래스에 상속되기 때문.


Instanceof 연산자 사용
 레퍼런스가 가르키는 객체의 타입 식별

instanceof 연산자의 활용예제 ( by.코드 )
[ ex.code ]-----------------------------------------------------
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        System.out.println(myDog instanceof Animal); // true
        System.out.println(myDog instanceof Dog);    // true
        System.out.println(myDog instanceof Cat);    // false

        System.out.println(myCat instanceof Animal); // true
        System.out.println(myCat instanceof Dog);    // false
        System.out.println(myCat instanceof Cat);    // true
    }
}

설명: 이 예제는 instanceof 연산자를 사용하여 각 객체가 Animal 클래스, Dog 클래스 또는 Cat 클래스의 인스턴스인지를 확인한다.
[ ex.code ]------------------------------------------------------

메소드 오버라이딩의 개념
1. 메소드 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 덮어쓰는 것, 이를 통해 하위 클래스는 상위 클래스의 동작을 재정의할 수 있다. 이 개념은 다형성을 지원하며, 런타임 시에 객체의 실제 타입에 따라 적절한 메소드가 호출이 됨

오버라이딩의 목적, 다향성 실현
1. 오버라이딩 + 다향성
    <1>하나의 인터페이스에 서로 다른 구현
    <2>슈퍼 클래스의 메소드를 서브 클래세어서 각각 목적에 맞게 다르게 구현

 

## 4월 5일 강의
#### 내용정리
메소드의 배열 리턴 - 배열의 레퍼런스만 이턴 (배열 전체가 리턴되는것이 아님)
메소드의 리턴 타임
- 리턴하는 배열 타입과 리턴 받는 배열 타입 일치
- 이천 차입에 배열의 크기를 지정하지 않음
자바의 예외처리 
예외 - 실행 중 오동작이나 결과에악영향을 미치는 예상치 못한 상황이 발생
실행 중 예외가 발생하면 - 자바 플랫폼은 응용프로그램이 예외를 처러하도록 호출
예외 발생 경우
-정수를 0으로 나누는 경우
-배열의 크기보다 큰 인덱스로 배열의 원소를 접급하는경우
-정수를 읽는 코드가 실행되고 있을 떄 사용자가 문자를 입력한 경우
자바의 예외처리, try-catch-finaly문
자바의 예외 클래스
배열의 범위를 벗어나 원소를 접근하는 예외 처리
-자바에서 배열의 범위를 벗어나 원소를 접근하려고 할 때 발생하는 예외는 ArrayIndexOutOfBoundsException이고
 이 예외는 배열의 유효하지 않은 인덱스에 접근하려고 할 때 발생 배열의 유효한 인덱스 범위는 0부터 배열의 길이 - 1까지이며
 이 범위를 벗어나는 인덱스에 접근하면 이 예외가 발생

실세꼐 객체의 특징
- 객체마다 고유한 특성과 행등을 가짐
- 다른 객체들과 정보를 주고 받는 등, 상호작용하면서 살아감
컴퓨터 프로그램에서 객체 사례
테트리스 게임의 각 블록들 
한글 프로그램의 메뉴나 버튼들
캡슐화 - 객체의 가장 본질적인 특징 - 외부의 접근으로부터 객체 보호
자바의 캡슐화 
- 클래스: 객체 모양을 선언한 틀
-객체 : 생성된 실체
자바의 객체 지향 특성 : 상속
-상속 상위 개체의 속성이 하위 개체에 물려짐, 하위 개체가 상위 개체의 속성을 모두 가지는 관계
상위 클래스 - 수퍼 클래스
하위 클래스 - 서브 클래스, 수퍼 클래스 코드의 재사용 , 새로운 특성 추가 기능
다형성
- 같은 이름으 ㅣ메소드가 클래스 혹은 객체에 따라 다르게 구현되는것
다형성 사례 
- 메소드 오버로딩 : 한클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
- 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스 마다 다르게 구현
소프트웨어의 생산성 향상
- 컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축 - 소프트 웨어를 빠른 속도로 생산할 필요성 증대
객체 지향 언어
- 상속,다형성,객체,캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
-소프트웨어 재사용과 부분 수정 빠름
-소프트웨어를 다시 만드는 부담 대폭 줄임
-소프트웨어 생산성 향상
실세계의 대한 쉬운 모델링 
- 초기 프로그래밍 - 수학계산.통계 처리를 하는 등 처리과정
절차 지향 프로그래밍 
- 작업 순서를 표현하는 컴퓨터 명령 집합
함수들의 집합으로 프로그램 작성
객체지향 프로 그래밍
- 컴퓨터가 수행하는 작업을 객체들간의 상호 작용르로 표현 
클래스 혹은 객체들의 집합으로 프로그램 작성
글래스 
-객체의 속성과 행위 선언
객체의 설계도 혹은 틀
객체
- 클래스의 트로 찍어낸 실체 - 프로그램 실행 중에 생성되는 실체, 메모리 공간을 갖는 구체적인 실체, 인스턴스 라고도 부름
사례 - 클래스:소나타 자동차,객체 출고된 실제 소나타 100대 ,클래스: 벽시계 , 객체 : 우리집 벽에 걸린 벽시계들
클래스 
- class 키워드로 선언
-멤버 : 클래스 구성요소 - 필드와 메소드
클래스의 데한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용
생성자의 특징
-생성자 이름은 클래스 이름과 동일 
-생성자는 여러 개 작성 가능(생성자 중복)
생성자는 객체 생성시 한번만 호출
기본 생성자가 자동 생성되는 경우
클래스에 생성자가 하나도 선언 되어 있지 않을 때 - 컴파일러에 의해 기본 생성자 자동 생성
this 래퍼런스
this 
객체 자신에 대한 레퍼런스
-컴파일러에 의해 자동관리,개발자는 사용하기만 하면 됨
-this.멤버 형태로 접근할때 사용
this() - 같은 클래스의 다른 생성자 호출,생성자 내에서만 사용 가능, 생성자 코드의 제일 처음에 있어야 함
자바의 객체배열 - 객체에 대한 레퍼런스 배열임
자바의 객체배열 만들기 3단계 - 배열 레처런스 변수 선언,레퍼런스 배열 생성, 배열의 각 원소 객체 생성
메소드 - 메소드는 c/c++ 의 함수와 동일,자바의 모든 메소드는 반드시 클래스 안에 있어야 함
메소드 오버로딩 - 한클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
-메소드 이름이 동일하여야 함
매개 변수의 개수가 서로 다르거나 타입이 서로 달라야 함
객체 소명 - new에 의해 할당 받은 객체와 배열 메모리 포함,소멸된 객체 공간은 가용 메모리에 포함
자바에서 사용자 임의로 객체 소명안됨
-자바는 객체 소명 연산자 없음-객체 생성 연산자 :new
객체 소멸은 자바 가상 기계의 고유한 역할 
자바 개발자 에게는 매우 다행스러운 기는 
-c/c++ 에서는 할당 받은 객체를 개발자가 프로그램 내엣 삭제해야함
-c/c++ 의 프로그램 작성을 어렵게만드는 요인
- 자바에서 사용하지 않는 객체나 배열을 돌려주는 코딩 책입으로부터 개발자 해방
가비지 -가르키는 레퍼런스가 하나도 없는 객체 - 더이상 접근할 수 없어 사용할 수 없게 된 메모리 
가비지 컬렉션 -자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집,반환
강제 가비지 컬렉션 강제 수행
System 또는 Runtime 객체의 gc() 메소드 호출- 이코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청, 
그러나 자바 가상 기계가 가비지 컬렉션 시점을 전적으로 판단
패키지 - 상호관련 있는 클래스 파일을 저장하여 관리하는 디텍토리
자바 응용프로그램은 하나 이상의 패키지로 구성
접근 지정자 - 4가지 private,protected,public,디폴트
접근 지정자의 목정 
-클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
- 객체 지향 언어의 캡슐롸 정책은 멤버를 보호하는 것
클래스의 접근지정
- 다른 클래스에서 사용하도록 허용할 지 지정
public 클래서 - 다른 모든 클래스에게 접근 허용
디폴트 클래스
-packagge -private 라고도 함
- 같은 패키지의 클래스에만 접근 허용
static 멤버 
객체 생성과 non -static 멤버의 생성
non-static 멤버는 객체가 생성될 때,객체마다 생긴다
static 멤버는 클래스당 하나만 생성
객체들에 의해 공유됨
static 멤버 사용
- 클래스 이름으로 접근 가능
-객체의 멤버로 접근 가능
- non-static 멤버는 클래스 이름으로 접근 안됨

## 3월 29일강의
#### 내용정리
Scanner 클래스
읽은 바이트를 문자,정수,실수,문자열등 다양한 타입으로 변환하여 리턴
Scanner는 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽음
공백문자 : "\t" , "\f" , "\r" \ "n"
산술 연산자 
더하기(+) 뺴기(-) 곱하기(*) 나누기(/) 나머지(%)
증감 연산
++, --
대입 연산
int a = 1 ,b = 3;
a = b;
a += b;
조건 연산
3개의 피연산자로 구성된 삼항 연산자
opr1?opr2:opr3
opr1 이 true이면 연산식의 결과는 opr2, false이면 opr3
if else을 조건 연산자로 간결하게 표현 가능
비트 연산 
비트개념 = byte X = 10;
비트 논리 연산
피 연산자의 각 비트들을 대상으로 하는 연산
비트끼리 AND,OR,XOR,NOT 연산
비트 시프트 연산
비트를 오른쪽이나 왼쪽으로 이동
조건문 - 단순if 문 , if - else 문
단순 if 문
if의 괄호안에 조건식(논리형 변수나 논리 연산)
if-else 문 
조건식이 true면 실행문장1, false면 실행문장 2실행
다중 if-else 문
다중 if 문
조건문이 너무 많은 경우 swich 문 사용 권장
swich문
swich문은 식과 case 문의 값과 비교 
case의 비교 값과 일치하면 해당 case 의 실행문장 수행- break를 만나면 swich문을 벗어남
반복문
자바 반복문 - for 문, while 문 , do - while 문- for문  가장 많이 사용하는 반복문
 while문 - 조건식이 '참'인 동안 반복실행
 do-while문 - 조건식이 참인 동안 반복 실행 , 작업문은 한번 반드시 실행
braek 문 
반복문하나를 즉시 벗어갈 떄 사용
자바 배열
배열(array)
인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조- 배열을 이용하면 한 번에 많은 메모리 공간 선언 가능
배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간- 원소 데이터들이 순차적으로 저장됨,인젝스를 이용하여 원소 데티어 접근,반복문을 이용하여 처리하기에 적합한 자료구조
배열 인덱스 - 0부터 시작 , 인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대 위치
배열 선언 - 배열 공간 할당 받는 과정
배열 초기화 - 배열 생성과 값 초기화
래퍼런스 치환과 배열 공유 - 래퍼런스 치환으로 두 래퍼런스가 하나의 배열 공유
배열의 크기,lenght
자바의 배열은 객체로 처리
배열 객체의 lenght 필드- 배열의 크기는 배열객체의 lenght필드에 저장





## 3월 22일강의
#### 내용정리
깃 그래프로 태그 및 버젼을 넣을수있다
Ctrl + Shift +p  를 이용하여 자바 프로젝트를 쉽고 빠르게 만들수있다
프로그래밍의 역사에 대해서 배웠다 
자바 : java -> class 
자바
그린 프로젝트 : 선마이크로시즈템즈의 제임스 고슬링에 의해 시작{가전 제품에 들어갈 소프트웨어를 위해 개발}
플랫폼 호환성 문제 해결
플랫폼 돌릭적인 언어 개발
메모리 사용량이 적고 다양한 플랫폼을 가지는 가전 제품에 적용
WORA
자바는 한번 작성된 코드는 모든 플랫폼에서 바로 실행됨
기존 언어의 플랫폼 종속성 극복
자바의 특징{바이트 코드}
자바 소스를 컴파일한 목적 코드
CPU에 종속적이지 않는 중립적인 코드
JVM에 의해 해석되고 실행됨
JVM은 자바 바이트 코드를 실행하는 자바 가상 기계

실행 환경
자바 가상 기계 + 자바 플랫폼의 다양한 클래스 라이브러리(자바 API)
응용 프로그램 실행
main() 메소드를 가진 클래스의 main()에서 실핼

JDK
자바 응용 개발 환경, 개발에 필요한 도구 포함
JRE
자바 실행 환경
개발자가 아닌경우 JRE만 따로 다운 가능

자바 API
JDK에 포함된 클래스 라이브러리 
주요한 기능들을 미리 구현한 클래스 라이브러리의 집합
API에서 정의한 규격에 따라 글래스 사용
자바 패키지 
서로 관련된 클래스들을 분류하여 묶어 놓은 것
	클래스의 이름에 패키지 이름도 포함
	다른 패키지의 동일한 이름의 클래스 존재 가능
자바 통합 개발 환경-이클립스
IDE
통합 개발 환경
편집,컴파일,디버깅을 한번에 할 수 있는 통합된 개발 환경

이클립스
자바 응용 프로그램 개발을 위한 통합 개발 환경
IBM에 의해 개발된 오픈 소스 프로젝트

자바 모바일 응용 : 안드로이드 앱

자바의 특징
플랫폼 독립성
객체지향-캡슐화,상속,다형성 지원
클래스의 캡슐화
자바의 모슨 변수나 함수는 클래스 내에 선언
클래스 안에서 클래스(내부 클래스) 작성 가능
소스(.java) 와 클래스 (.class) 파일
하나의 소스 파일에 여러 클래스를 작성 가능 - public 클래스는 하나만 가능
소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 함
클래스 파일에는 하나의 클래스만 존재- 다수의 클래스를 가진 자바 소스를 컴파일하면 클래스마다 별도 클래스 파일 생성
실행 코드-자바 응용프로그램의 실행은 main() 메소드에서 시작
패키지-서로 관련 있는 여러 클래스를 패키지로 묶어 관리
멀티스레드- 여러 스레드의 동시 수행 환경 지원
가비지 컬렉션-자바 언어는 메모리 할당 기능은 있어도 메모리 변환 기능 없음
실시간 응용프로그램에 부적합-실행 도중 예측할 수 없는 시점에 가비지 컬렉션 실행 때문
자바 프로그램은 안전-타입 체크 엄격,물리적 주소를 사용하는 포인터 개념 없음
프로그램 작성 쉬움-포인터 개념이 없음 ,동적 메모리 반환 하지 않음,다양한 라이브러리 지원
실행 속도 개선을 위한 JIT 컴파일러 사용 - 자바는 바이트 코드를 인터프리터 방식으로 실행,JIT 컴파일 기법으로 실행 속도 개선
식별자-클래스,변수,상수,메소드 등에 붙이는 이름
식별자의 원칙-특수 문자,공백,탭은 식별자 사용불가지만 "_", "$"는 사용가능
자바의 데이터 타입 
기본타입- boolean,char,byte,short,int,long,float,doubel
문자열-문자열은 기본 타입아님
문자열 이터럴 - "JDK","한글","계속하세요"
변수-변수값은 프로그램 수행 중 변경될 수 있음
변수 선언 - 데이터 타입에서 정한 크기의 메모리 할당
리터럴-프로그램에서 직접 표현한 값,정수,실수,문자,놀리 ,문자열 리터럴 있음
정수 리터럴-10진수,8진수,16진수,2진수 리터럴








## 3월 15일 강의
#### 내용정리
깃 유저네임, 이메일 등록

깃배쉬 익스텐션 깔기

이클립스를 이용하여 Hello.java 실습

수업에서는 vscode 사용 예정 - vscode에 자바 익스텐션 실치

hello.java와 test.java 파일 만들기 - 커밋과 푸쉬

##### 코드블럭 생성 및 주석 처리
 ```java
 public class Test {
	public static void main(String[] args) {
		System.out.println("Hello");
		//Hello를 출력
	}
}
```

## 3월 8일 강의
깃 아이디 생성 및 깃 레파지토리 만들기
