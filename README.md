# 유민혁 학번 202130419
## 5월 24일 강의
#### 내용 정리

이벤트 기반 프로그래밍
이벤트의 발생에 의해 프로그램 효율이 결정되는 방식
- 이벤트가 발생하면 이벤트를 처리하는 루틴실행
- 실행할 코드는 이벤트의 발생에 의해 전적으로 결정
반대되는 개념: 배치 실행
-프로그램의 개발자가 프로그램이 호출을 결정하는 방식
이벤트 종휴
- 사용자의 입력 : 마우스 드래그, 마우스 클릭 , 키보드 누름등 
-센서로부터의 입력: 네트워크로부터 데이터 송수신
- 다른 응용프로그램이나 다른 스레드로부터의 메시지
이벤드 기반 응용 프로그램의 구조
- 각 이벤트마다 처리하는 리스너 코드 보유
GUI 응용 프로그램은 이벤트 기반 프로그래밍으로 작성됨 
GUI 라이브러리 종휴
C++ 의 MFC, C# GUI visual vasic, X window, Andorid 등
자바의 AWT와 Swing

이벤트가 처리되는 과정 
- 이벤트 발생 
- 이벤트 객체 생성
- 응용프로그램에 작성된 이벤트 리스너 찾기
- 이벤트 리스너 실행

이벤트 객체 
- 발생한 이벤트에 관한 정보를 가진 객체
- 이벤트 리스너에 전달됨 

이벤트 객체가 포함하는 정보
- 이벤트 종류와 이벤트 소스
- 이벤트가 발생한 화면 좌표 및 건포넌트 내 좌표
- 이벤트가 발생한 버튼이나 메뉴 아니템의 문자열
- 클릭된 마우스 버튼 및 마우스의 클릭 횟수
- 키의 코드 값과 문자 값
- 체크박스, 라디오버튼등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태

이벤트 소스를 알아 내는 메소드
Object getSource()
-발생한 이벤트의 소스 컴포넌트 리턴 
Object 타입으로 리턴하므로 캐스팅해여 사용
- 모든 이벤트 객체에 대해 적용

이벤트 리스너 
-이벤트를 처리하는 자바 프로그램 코드 클래스로 작성 
사용자의 이벤트 리스너 작성
- 자바의 리스너 인터페이스를 상속받아 구현
- 리스너 인터페이스의 모든 추상 메소드 구현

이벤트 리스너 작성 방법
- 3가지 방법 
독립 클래스로 작성
- 이벤트 리스너를 완전한 클래스로 작성
- 이벤트 리스너를 여러 곳에서 사용할때 적합
내부 클래스로 작성
- 클래스 안에 멤버처럼 클래스 작성
- 이벤트 리스너를 특정 클래스에서만 사용할 때 적합
익명 클래스 
- 클래스의 이름 없이 간단히 리스너 작성 
- 클래스 조차 만들 필요없이 리스너 코드가 간단한 경우에 적합

익명 클래스로 이벤트 리스너 작성
익명 클래서
- 클래스 선언 + 인스턴스 생성을 한번에 달성 
- 간단한 리스너의 경우 익명 클래스 사용 추천

어댑터 클래스 
- 이벤트 리스너

KEY 이벤트와 포커스 
키 입력시, 다음 세 경우 각각 KEY 이벤트 발생
- 키를 누르는 순간 
- 누른 키를 떼는 순간 
-누른 키를 뗴는 순간
키 이벤트를 받을 수 있는 조건 
- 모든 컴포넌트 
- 현재 포커스를 가진 컴포넌트가 키 이벤트 독점
포커스 
- 컴포넌트나 응용프로그램이 키 이벤트를 독점하는 권한

KEYListner 
- 응용프로그램에서 KEYListner 를 상속받아 키 리스너 구현

유니코드 키
유키코드 키의 특징
- 국제 산업 표준
- 전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체게
- 문자들에 대해서만 키 코드 값 입력
유니코드 키가 입력 되는 경우
- KEYpressed(),KEYTyped(),KEYReleased() rk tnstjeofh ghcnf
유니코드 키가 아닌 경우
- keyPressed()
가상키와 입력된 키 판별
KEYEvent 객체
- 입력된 키 정보를 가진 이벤트 객체
- KeyEvent 객체의 메소드로 입력된 키 판별

KeyEvent 객체의 메소드로 입력된 키 판별
- charKeyEventget(Keychar)
- 키의 유니코드 문자 값 리턴 
- uncode 문자 키인 경우에만 의미 있음


## 5월 17일 강의
#### 내용정리

FLOWLAyout 배치관리자
-컴포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치
- 배치할 공간이 없으면 아래로 내려와서 반복한다
BorderLayout 배치 관리자
- 컨테이너의 공간을 동 서 남 북 중앙의 5개의 영역으로 나눔
- 5개의 영역 중 응용프로그램에서 지정한 영역으로 나눔
배치 방법
add(Component comp, int index)
GridLatout 배치관리자 
-컨테이너를 프로그램에서 성정한 동일한 크기의 2차원 격자로 나눔
-컴포넌트는 삽입 순서대로 좌에서 우로 다시 위에서 아래로 배치
CardLayout
-컨테이너의 공간에 카드를 쌓아 놓는듯이 컴포넌트를 포개어 배치
컨테이너의 디폴트 배치 과니자
- 컨테이너 생성시 자동으로 생성되는 배치 관리자
- AWT와 스윙 컨테이너
- 디폴트 배치 관리자
컨테이너에 새로운 배치관리자 성정
-setLayout 메소드 호출
- im을 새로운 배치 관리자로 설정
-JPanel 컨테이너에 BorderLauout 배치관리자를 설정하는 예
JPanel p = new JPanel();
p.serLayout(new BorederLayout();) // JPanel에 BorderLayout 설정
배치방법 - 컴포넌트를 컨테이너 내에 왼쪽에서 오른쪽으로 배치
- 다시 위에서 아래소 순서대로 배치
생성자
-FlowLayout()
-FlowLayout(int hGao, int vGap)
align : 컴포넌트를 정렬하는 방법 지정, 왼쪽 정렬 오른쪽 정렬 중앙 정렬
hgap : 좌우 두 컴포넌트 사이의 수평 간격 픽셀 단위, 디폴트는 5
vgap : 상하 두 컴포넌트 사이의 수평 간격 픽셀 단위, 디폴트는 5
GridLayout 생성자
- Gridlayout()
- GridLayout(int rows, int cols)
- GridLayout(int rows, int cols, int hGap, int vGap)
- rows : 격자의 행수 디폴트 1
- cols 격자의 열수 디폴트 1
- hGap: 좌우 두 컴포턴트 사이의 수평 간격 , 픽셀단위 디폴트 0
- vGap : 상하 두 컴포넌트 사이의 수직 간격, 픽셀 단위 디폴트 0
- rows x cols 만큼의 셀을 가진 격자로 컨테이너 공간을 분할, 배치
배치관리자가 없는 컨테이너가 필요한 경우 - 응용프록램에서 직접 컴포넌트의 크기와 위치를 결정하고자 하는 경우
1 컴포넌트의 크기나 위치를 개발자 임읠결정하고자 하는경우
2 게임 프로그램과 같이 시간이나 마우스/키보드의 입력에 따라 컴포넌트들의 위치와 크기가 변하는경우 
3 여러 컴포넌트들이 서로 겹쳐 출력하고자 하는 경우
배치관리작가 없는 컴테이너에 컴포넌트를 삽입할 떄 
프로그램에서 컴포넌트의 절대 크기와 위치 설정
컴포넌트들이 서로 겹치게 할수 있음
컴포넌트의 크기와 위치 설정 메소드
void setSize(int width, int height)



## 4월 19일 강의
#### 내용정리
추상 메소드 
abstract로 선언된 메소드 메소드의 코드는 없고 원형만 선언
추상 클래스 상속 
- 추상 클래스를 상속받으면 추상클래스가 됨
- 서브 클래스도 abstract로 선언해야 함
추상 ㅡㄹ래스 구현 
-서브 클래스에서 슈퍼 클래스의 추상 메소드 구현(오버라이딩)
-추상 클래스를 구현한 서브 클래스는 추상 클래스 아님
추상 클래스의 목적
-상속을 위한 슈퍼 클래스로 활용하는것
-서브 클래스에서 추상 메소드 구현
-다형성 실현
자바의 인터페이스
-클래스가 구현해야 할 메소드들이 선언되는 추상형
-인터페이스 선언 - interface 키워드로 선언 - EX) public interface SerialDriver
자바 인터페이스에 대한 변화
- JAVA 7까지 - 인터페이스는 상수와 추상 메소드로만 구성
- JAVA 8 부터
인터페이스의 구성 요소들 -상수와 추상메소드 포함,defalut 메소드 포함,private 메소드 포함

인터페이스의 구성 요소들의 특징
- 메서드 시그니처(Method Signature): 메서드의 이름, 매개변수 목록, 반환 유형으로 구성되고, 메서드의 내용은 없으며 단지 정의만 포함

- 상수(Constant): 상수는 인터페이스 내에서 선언되는 변수로, 값을 변경할 수 없는 고정된 값, 주로 관련된 상수들을 그룹화하여 사용

- 디폴트 메서드(Default Method): Java 8부터 도입된 기능으로, 인터페이스에 메서드의 구현을 제공하고, 구현된 메서드를 갖게 됨으로써, 해당 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩 안함

-  정적 메서드(Static Method): Java 8부터 지원되며, 정적 메서드는 인터페이스에 속하면서도 인스턴스를 생성하지 않고도 호출할 수 있는 메서드, 주로 도우미 함수나 유틸리티 메서드를 제공하는 데 사용

-  추상 메서드(Abstract Method): 메서드의 정의만 있고 구현이 없는 메서드, 이러한 메서드들은 인터페이스를 구현하는 클래스에서 반드시 구현되어야 함

인터페이스 상속/구현
-  인터페이스의 추상 메소드를 모두 구현한 클래스 작성
    <1>implements 키워드 사용
    <2>여러개의 인터페이스 사용 가능-
패키지 
-서로 관련된 클래스와 인터페이스를 컴파일한 클래스 파일들을 묶어놓은 디렉토리
-하나의 응용 프로그램은 한개 이상의 패키지로 작성
패키지는 jar파일로 아북할수 있음
모듈
-여러 패키지와 이미지들의 자원을 모아 놓은 컨테이너 
-하나의 모듈을 하나의 .jmod파일에 저장
JAVA9 부터 모듈화 도입
- 플랫폼의 모듈화
- 몯ㄹ화의 목적 
-Java 9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성
java 8까지는 rt.jar의 한파일에 모드 API 저장
-응용프로그램이 실행핳때 꼭 필요한 모듈들로만 실행 환경 구축
-메모리 자원이 열악한 작은 소형 기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
모듈의 현실
-java 9 부터 전면적으로 도입
-복잡한 개념
-큰 자바 응용프로그램에는 개발 ,유지보수 등에 적합
-현실적으로 모듈로 나누어 자바프로그램을 작성할 필요 없음
자바 JDK에 자공되는 모듈 파일들 
- 자바가 설치된 hmods디렉토리에 모듈 파일 존재 - .jmod 확장자를 가진 파일, 모듈은 수십개 ,모듈 파일은 ZIP포맷으로 압축된 파일
모듈 파일에는 자바 API의 패키지와 크래스들이 들어있음
jmod 명령을 이용하여 모듈 파일에 들어있는 패키지를 풀어낼수있음
다은 패키지에 작성된 클래스 사용
- import를 이용하지 않는 경우 - 소스에 클래스 이름의 완전 경로명 사용
2. 필요한 클래스만 import
    <1>소스 시각 부분에 클래스의 경로명 import
    <2>import 패키지, 클래스
    <3>소스에는 클래스 명만 명시하면 됨

3. 패키지 전체를 import
    <1>소스 시각 부분에 패키지의 경로명 import
    <2>import 패키지.*
    <3>import.java.util.*
클래스 파일이 저장되는 윈치는 
-클래스나 인터페이스가 컴파일되면 클래스 파일 생성
클래스 파일은 패키지로 선언된 디렉터리에 저장
패키지 선언
-소스 파일의 맨앞에 컴파일 후 저장될 패키지 지정
package 선언문이 없는 자바 소스 파일의 경우
-컴파일러는 
모듈 
-java 9에서 도입된 개념
-패키지와 이미지등의 리소스를 담은 컨테이너 
-모듈 파일(.jmod)로 저장
자바 모듈화의 목적
-자바 컴포넌트들을 필요에 따라 조립하여 사용하기 위함
-컴퓨터 시스템의 불필요한 부담 감소 - 세밀한 모듈화를 통해 필요 없는 모듈이 로드되지않게 함, 소형 IOT장치에도 자바 응용프로그램이 실행되고 
java.lang
-스트링,수학 함수
object 클래스 특징
-모든 자바 클래스는 반드시 Object를 상속받도록 자동 컴파일 - 모든 크래스의 수퍼 클래스
객체의 속성을 나타내는 메소드로는 toString(), hashCode(), equals(), getClass() 등이 있습니다.
이러한 메소드들은 모든 자바 클래스에서 사용할 수 있으며, 필요에 따라 오버라이딩하여 해당 클래스의 속성에 맞게 동작을 재정의할 수 있습니다.
toString() 메소드는 객체를 문자열로 표현하는 데 사용되며, hashCode() 메소드는 객체의 해시 코드를 반환합니다.
equals() 메소드는 객체 간의 동등성을 비교하고, getClass() 메소드는 객체의 클래스를 반환합니다.

toString() 메소드, 객체를 문자열로 변환

1. 각 클래스는 toString()을 오버라이딩하여 자신만의 문자열 리턴 가능
    <1>객체를 문자열로 반환
    <2>원형

2. 컴파일러에 의한 바이트 코드
    <1>자바 소스 코드는 컴파일러에 의해 바이트 코드로 변환됩니다.
    <2>컴파일러는 toString() 메소드를 오버라이딩한 경우에도 해당 메소드를 유지하고, 오버라이딩된 내용을 반영한 바이트 코드를 생성합니다.
    <3>따라서 컴파일 이후에도 오버라이딩된 toString() 메소드가 호출되어 객체를 문자열로 변환할 수 있습니다.

객체 비교(==)와 equals()메소드
1. == 연산자
    <1>객체 레퍼런스를 비교

2. boolean.equals()
    <1>두 객체의 내용물 비교
    <2>객체의 내용물을 비교하기 위해 클래스의 맴버로 작성

wrapper 클래스
1. 자바의 기본타입을 클래스화한 8개 클래스를 통칭

2. 용도
    <1>객체만 사용할 수 있는 켈렉션 등에 기본 타입의 값을 사용하기 위해 wrapper 객체로 만들어서 사용

주요 메소드
1. 가장 많이 사용하는 integer 클래스의 주요 메소드
    <1>다른 wrapper 클래스와 메소ㅓ드는 이와 유사

2. 메소드 종류/설명
    <1>toString(): 객체를 문자열로 반환합니다.
    <2> hashCode(): 객체의 해시 코드를 반환합니다.
    <3>equals(Object obj): 다른 객체와 동등한지 여부를 판단합니다.
    <4> getClass(): 객체의 클래스 정보를 반환합니다.
    <5> notify(): 대기 중인 하나의 스레드를 깨웁니다.
    <6>notifyAll(): 대기 중인 모든 스레드를 깨웁니다.
    <7> wait(): 스레드를 일시 정지시킵니다.

박싱과 언박싱
1. 박싱
    <1>기본 타입의 값을 wrapper 객체로 변환하는 것

2. 언박싱
    <1>Wrapper 클래스의 객체에서 기본 타입의 값을 추출하는 것
    Wrapper 클래스는 기본 데이터 타입을 감싸는 클래스로, 예를 들어 Integer, Double, Boolean 등
    <2>언박싱은 Wrapper 클래스의 객체에서 intValue(), doubleValue(), booleanValue() 등의 메소드를 사용하여 해당 기본 타입의 값을 추출

String 활용
1. String의 생성:
    문자열을 생성하고 문자열 리터럴을 저장하는 객체
    쌍따옴표(" ")로 감싸진 문자열 리터럴을 사용하여 String 객체를 생성가능
    문자열 연결 (Concatenation): '+' 연산자를 사용하여 문자열을 연결가능
    문자열 리터럴과 변수, 또는 문자열 변수와 문자열 변수를 연결가능

2. 문자열의 길이 확인:
    length() 메소드를 사용하여 문자열의 길이를 확인
    공백을 포함하여 문자열의 전체 길이를 반환

3. 문자열 비교:
    equals() 메소드를 사용하여 두 문자열이 동일한지 비교
    equalsIgnoreCase() 메소드는 대소문자를 무시하고 비교

4. 부분 문자열 추출:
    substring() 메소드를 사용하여 문자열의 일부분을 추출
    시작 인덱스와 종료 인덱스를 지정하여 추출

5. 문자열 검색:
    indexOf() 메소드를 사용하여 특정 문자 또는 문자열이 처음으로 등장하는 위치확인 가능
    lastIndexOf() 메소드는 문자열의 끝에서부터 검색을 수행

6. 문자열 분할:
    split() 메소드를 사용하여 문자열을 특정 구분자를 기준으로 분할
    분할된 부분은 문자열 배열로 반환

7. 문자열 치환:
    replace() 메소드를 사용하여 문자열 내의 특정 문자 또는 문자열을 다른 문자열로 대체
    대체될 문자열이 없으면 원래 문자열을 그대로 반환


## 4월 12일 강의
#### 내용정리 
static 메소드는 오직 static 멤버만 접근 가능
-객체가 생성되지 않은 상화에서도 static 메소드는 실행될 수 있기 떄문에 ,non-static 멤버 활용 불가
-non-static 메소드는 static 멤버 활용 가능 
static 메소드는 this 사용 불가
- static 메소드는 객체없이도 사용 가능하므로 this 레퍼런스 사용할수 없음
상속 선언 
extends 키워드로 선언 -부모 클래스를 물려받아 확장한다는 의미
부모 클래서 -> 슈퍼클래스
자식 클래스 -> 서브 클래스
서브 클래스 객체의 모양
- 슈퍼 클래스 객체와 서브클래스의 객체는 별개
- 서브 클래스 객체는 슈퍼 클래스 멤버 포함
자바의 상속의 특징
클래스 다중 상속 불허
-C++ 은 다중상속 클래스가 가능 

슈퍼 클래스의 멤버에 대한 서브 클래스의 접근
- 슈퍼 클래스의 private 멤버 - 서브 클래스에서 접근 할수 없음
슈퍼 클래스의 디폴트 멤버
- 서브 클래스가 동일한 패키지에 있을떄 접근간으
슈퍼 클래스의 public 멤버
-서브 클래스는 항상 접근 가능
슈퍼클래스의 protected 상속
 protected 멤버에 대한 접근
 -같은 패키지의 모든 클래스에게 허용
 - 상속되는 서브 클래스(같은 패키지든 다른 패키지든 상관 없음)에게 허용
 서브 클래스의 개게가 생성될 때
 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
 슈퍼 클래스와 서브 클래스
 - 각각 여러 개의 생성자 작성 가능
 서브 클래스의 객체가 생성될 때
 - 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 ㅂㅇ식
 1 개발자의 명시적 선택
 - 서브 클래스 개발자가 슈퍼 클래스의 생성자 명시적 선택
 - super() 키워드를 이용하여 선택
 2 컴파일러가 기본 생성자 선택
 super() 
 -서브 클래스에서 명시적으로 슈퍼클래스 호출
 

업캐스팅의 개념
업캐스팅은 하위 클래스를 상위 클래스 타입으로 변환하는 것. 상속 계층 구조에서 자주 사용되며, 다형성을 활용하여 다양한 객체를 동일한 인터페이스로 다룰 수 있게 컴파일 타임 다형성을 제공하여 유연하고 확장 가능한 코드를 작성하는 데 도움이 됨

업캐스팅
서브 클래스의 레퍼런스를 슈퍼 클래스 레퍼런스에 대입
슈퍼 클래스 레퍼런스로 서브 클래스 객체를 가르키게 되는 현상

다운캐스팅의 개념
다운캐스팅은 상위 클래스 타입을 하위 클래스 타입으로 변환하는 것. 업캐스팅과 반대되며 명시적인 형 변환을 필요로, 주로 상위 클래스로 선언된 객체를 실제로는 하위 클래스로 사용해야 할 때 사용되며 타입 안전성을 보장하기 위해 주의해서 사용해야 함

다운캐스팅
슈퍼 클래스 레퍼런스를 서브 클래스 레퍼런스에 대입
업캐스팅된 것을 다시 월래대로 되돌리는 것
반드시 명시적 타입 변환 지정

[ 업캐스팅 레퍼런스로 객체 구별?? ]
업캐스팅된 레퍼런스로는 객체의 실제 타입을 구분하기 어려움
    --> 슈퍼 클래스에서 여러 서브 클래스에 상속되기 때문.


Instanceof 연산자 사용
 레퍼런스가 가르키는 객체의 타입 식별

instanceof 연산자의 활용예제 ( by.코드 )
[ ex.code ]-----------------------------------------------------
class Animal {}
class Dog extends Animal {}
class Cat extends Animal {}

public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        System.out.println(myDog instanceof Animal); // true
        System.out.println(myDog instanceof Dog);    // true
        System.out.println(myDog instanceof Cat);    // false

        System.out.println(myCat instanceof Animal); // true
        System.out.println(myCat instanceof Dog);    // false
        System.out.println(myCat instanceof Cat);    // true
    }
}

설명: 이 예제는 instanceof 연산자를 사용하여 각 객체가 Animal 클래스, Dog 클래스 또는 Cat 클래스의 인스턴스인지를 확인한다.
[ ex.code ]------------------------------------------------------

메소드 오버라이딩의 개념
1. 메소드 오버라이딩은 상위 클래스의 메소드를 하위 클래스에서 덮어쓰는 것, 이를 통해 하위 클래스는 상위 클래스의 동작을 재정의할 수 있다. 이 개념은 다형성을 지원하며, 런타임 시에 객체의 실제 타입에 따라 적절한 메소드가 호출이 됨

오버라이딩의 목적, 다향성 실현
1. 오버라이딩 + 다향성
    <1>하나의 인터페이스에 서로 다른 구현
    <2>슈퍼 클래스의 메소드를 서브 클래세어서 각각 목적에 맞게 다르게 구현

 

## 4월 5일 강의
#### 내용정리
메소드의 배열 리턴 - 배열의 레퍼런스만 이턴 (배열 전체가 리턴되는것이 아님)
메소드의 리턴 타임
- 리턴하는 배열 타입과 리턴 받는 배열 타입 일치
- 이천 차입에 배열의 크기를 지정하지 않음
자바의 예외처리 
예외 - 실행 중 오동작이나 결과에악영향을 미치는 예상치 못한 상황이 발생
실행 중 예외가 발생하면 - 자바 플랫폼은 응용프로그램이 예외를 처러하도록 호출
예외 발생 경우
-정수를 0으로 나누는 경우
-배열의 크기보다 큰 인덱스로 배열의 원소를 접급하는경우
-정수를 읽는 코드가 실행되고 있을 떄 사용자가 문자를 입력한 경우
자바의 예외처리, try-catch-finaly문
자바의 예외 클래스
배열의 범위를 벗어나 원소를 접근하는 예외 처리
-자바에서 배열의 범위를 벗어나 원소를 접근하려고 할 때 발생하는 예외는 ArrayIndexOutOfBoundsException이고
 이 예외는 배열의 유효하지 않은 인덱스에 접근하려고 할 때 발생 배열의 유효한 인덱스 범위는 0부터 배열의 길이 - 1까지이며
 이 범위를 벗어나는 인덱스에 접근하면 이 예외가 발생

실세꼐 객체의 특징
- 객체마다 고유한 특성과 행등을 가짐
- 다른 객체들과 정보를 주고 받는 등, 상호작용하면서 살아감
컴퓨터 프로그램에서 객체 사례
테트리스 게임의 각 블록들 
한글 프로그램의 메뉴나 버튼들
캡슐화 - 객체의 가장 본질적인 특징 - 외부의 접근으로부터 객체 보호
자바의 캡슐화 
- 클래스: 객체 모양을 선언한 틀
-객체 : 생성된 실체
자바의 객체 지향 특성 : 상속
-상속 상위 개체의 속성이 하위 개체에 물려짐, 하위 개체가 상위 개체의 속성을 모두 가지는 관계
상위 클래스 - 수퍼 클래스
하위 클래스 - 서브 클래스, 수퍼 클래스 코드의 재사용 , 새로운 특성 추가 기능
다형성
- 같은 이름으 ㅣ메소드가 클래스 혹은 객체에 따라 다르게 구현되는것
다형성 사례 
- 메소드 오버로딩 : 한클래스 내에서 같은 이름이지만 다르게 작동하는 여러 메소드
- 메소드 오버라이딩 : 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스 마다 다르게 구현
소프트웨어의 생산성 향상
- 컴퓨터 산업 발전에 따라 소프트웨어의 생명주기 단축 - 소프트 웨어를 빠른 속도로 생산할 필요성 증대
객체 지향 언어
- 상속,다형성,객체,캡슐화 등 소프트웨어 재사용을 위한 여러 장치 내장
-소프트웨어 재사용과 부분 수정 빠름
-소프트웨어를 다시 만드는 부담 대폭 줄임
-소프트웨어 생산성 향상
실세계의 대한 쉬운 모델링 
- 초기 프로그래밍 - 수학계산.통계 처리를 하는 등 처리과정
절차 지향 프로그래밍 
- 작업 순서를 표현하는 컴퓨터 명령 집합
함수들의 집합으로 프로그램 작성
객체지향 프로 그래밍
- 컴퓨터가 수행하는 작업을 객체들간의 상호 작용르로 표현 
클래스 혹은 객체들의 집합으로 프로그램 작성
글래스 
-객체의 속성과 행위 선언
객체의 설계도 혹은 틀
객체
- 클래스의 트로 찍어낸 실체 - 프로그램 실행 중에 생성되는 실체, 메모리 공간을 갖는 구체적인 실체, 인스턴스 라고도 부름
사례 - 클래스:소나타 자동차,객체 출고된 실제 소나타 100대 ,클래스: 벽시계 , 객체 : 우리집 벽에 걸린 벽시계들
클래스 
- class 키워드로 선언
-멤버 : 클래스 구성요소 - 필드와 메소드
클래스의 데한 public 접근 지정 : 다른 모든 클래스에서 클래스 사용 허락
멤버에 대한 public 접근 지정 : 다른 모든 클래스에게 멤버 접근 허용
생성자의 특징
-생성자 이름은 클래스 이름과 동일 
-생성자는 여러 개 작성 가능(생성자 중복)
생성자는 객체 생성시 한번만 호출
기본 생성자가 자동 생성되는 경우
클래스에 생성자가 하나도 선언 되어 있지 않을 때 - 컴파일러에 의해 기본 생성자 자동 생성
this 래퍼런스
this 
객체 자신에 대한 레퍼런스
-컴파일러에 의해 자동관리,개발자는 사용하기만 하면 됨
-this.멤버 형태로 접근할때 사용
this() - 같은 클래스의 다른 생성자 호출,생성자 내에서만 사용 가능, 생성자 코드의 제일 처음에 있어야 함
자바의 객체배열 - 객체에 대한 레퍼런스 배열임
자바의 객체배열 만들기 3단계 - 배열 레처런스 변수 선언,레퍼런스 배열 생성, 배열의 각 원소 객체 생성
메소드 - 메소드는 c/c++ 의 함수와 동일,자바의 모든 메소드는 반드시 클래스 안에 있어야 함
메소드 오버로딩 - 한클래스 내에서 두 개 이상의 이름이 같은 메소드 작성
-메소드 이름이 동일하여야 함
매개 변수의 개수가 서로 다르거나 타입이 서로 달라야 함
객체 소명 - new에 의해 할당 받은 객체와 배열 메모리 포함,소멸된 객체 공간은 가용 메모리에 포함
자바에서 사용자 임의로 객체 소명안됨
-자바는 객체 소명 연산자 없음-객체 생성 연산자 :new
객체 소멸은 자바 가상 기계의 고유한 역할 
자바 개발자 에게는 매우 다행스러운 기는 
-c/c++ 에서는 할당 받은 객체를 개발자가 프로그램 내엣 삭제해야함
-c/c++ 의 프로그램 작성을 어렵게만드는 요인
- 자바에서 사용하지 않는 객체나 배열을 돌려주는 코딩 책입으로부터 개발자 해방
가비지 -가르키는 레퍼런스가 하나도 없는 객체 - 더이상 접근할 수 없어 사용할 수 없게 된 메모리 
가비지 컬렉션 -자바 가상 기계의 가비지 컬렉터가 자동으로 가비지 수집,반환
강제 가비지 컬렉션 강제 수행
System 또는 Runtime 객체의 gc() 메소드 호출- 이코드는 자바 가상 기계에 강력한 가비지 컬렉션 요청, 
그러나 자바 가상 기계가 가비지 컬렉션 시점을 전적으로 판단
패키지 - 상호관련 있는 클래스 파일을 저장하여 관리하는 디텍토리
자바 응용프로그램은 하나 이상의 패키지로 구성
접근 지정자 - 4가지 private,protected,public,디폴트
접근 지정자의 목정 
-클래스나 일부 멤버를 공개하여 다른 클래스에서 접근하도록 허용
- 객체 지향 언어의 캡슐롸 정책은 멤버를 보호하는 것
클래스의 접근지정
- 다른 클래스에서 사용하도록 허용할 지 지정
public 클래서 - 다른 모든 클래스에게 접근 허용
디폴트 클래스
-packagge -private 라고도 함
- 같은 패키지의 클래스에만 접근 허용
static 멤버 
객체 생성과 non -static 멤버의 생성
non-static 멤버는 객체가 생성될 때,객체마다 생긴다
static 멤버는 클래스당 하나만 생성
객체들에 의해 공유됨
static 멤버 사용
- 클래스 이름으로 접근 가능
-객체의 멤버로 접근 가능
- non-static 멤버는 클래스 이름으로 접근 안됨

## 3월 29일강의
#### 내용정리
Scanner 클래스
읽은 바이트를 문자,정수,실수,문자열등 다양한 타입으로 변환하여 리턴
Scanner는 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽음
공백문자 : "\t" , "\f" , "\r" \ "n"
산술 연산자 
더하기(+) 뺴기(-) 곱하기(*) 나누기(/) 나머지(%)
증감 연산
++, --
대입 연산
int a = 1 ,b = 3;
a = b;
a += b;
조건 연산
3개의 피연산자로 구성된 삼항 연산자
opr1?opr2:opr3
opr1 이 true이면 연산식의 결과는 opr2, false이면 opr3
if else을 조건 연산자로 간결하게 표현 가능
비트 연산 
비트개념 = byte X = 10;
비트 논리 연산
피 연산자의 각 비트들을 대상으로 하는 연산
비트끼리 AND,OR,XOR,NOT 연산
비트 시프트 연산
비트를 오른쪽이나 왼쪽으로 이동
조건문 - 단순if 문 , if - else 문
단순 if 문
if의 괄호안에 조건식(논리형 변수나 논리 연산)
if-else 문 
조건식이 true면 실행문장1, false면 실행문장 2실행
다중 if-else 문
다중 if 문
조건문이 너무 많은 경우 swich 문 사용 권장
swich문
swich문은 식과 case 문의 값과 비교 
case의 비교 값과 일치하면 해당 case 의 실행문장 수행- break를 만나면 swich문을 벗어남
반복문
자바 반복문 - for 문, while 문 , do - while 문- for문  가장 많이 사용하는 반복문
 while문 - 조건식이 '참'인 동안 반복실행
 do-while문 - 조건식이 참인 동안 반복 실행 , 작업문은 한번 반드시 실행
braek 문 
반복문하나를 즉시 벗어갈 떄 사용
자바 배열
배열(array)
인덱스와 인덱스에 대응하는 데이터들로 이루어진 자료 구조- 배열을 이용하면 한 번에 많은 메모리 공간 선언 가능
배열은 같은 타입의 데이터들이 순차적으로 저장되는 공간- 원소 데이터들이 순차적으로 저장됨,인젝스를 이용하여 원소 데티어 접근,반복문을 이용하여 처리하기에 적합한 자료구조
배열 인덱스 - 0부터 시작 , 인덱스는 배열의 시작 위치에서부터 데이터가 있는 상대 위치
배열 선언 - 배열 공간 할당 받는 과정
배열 초기화 - 배열 생성과 값 초기화
래퍼런스 치환과 배열 공유 - 래퍼런스 치환으로 두 래퍼런스가 하나의 배열 공유
배열의 크기,lenght
자바의 배열은 객체로 처리
배열 객체의 lenght 필드- 배열의 크기는 배열객체의 lenght필드에 저장





## 3월 22일강의
#### 내용정리
깃 그래프로 태그 및 버젼을 넣을수있다
Ctrl + Shift +p  를 이용하여 자바 프로젝트를 쉽고 빠르게 만들수있다
프로그래밍의 역사에 대해서 배웠다 
자바 : java -> class 
자바
그린 프로젝트 : 선마이크로시즈템즈의 제임스 고슬링에 의해 시작{가전 제품에 들어갈 소프트웨어를 위해 개발}
플랫폼 호환성 문제 해결
플랫폼 돌릭적인 언어 개발
메모리 사용량이 적고 다양한 플랫폼을 가지는 가전 제품에 적용
WORA
자바는 한번 작성된 코드는 모든 플랫폼에서 바로 실행됨
기존 언어의 플랫폼 종속성 극복
자바의 특징{바이트 코드}
자바 소스를 컴파일한 목적 코드
CPU에 종속적이지 않는 중립적인 코드
JVM에 의해 해석되고 실행됨
JVM은 자바 바이트 코드를 실행하는 자바 가상 기계

실행 환경
자바 가상 기계 + 자바 플랫폼의 다양한 클래스 라이브러리(자바 API)
응용 프로그램 실행
main() 메소드를 가진 클래스의 main()에서 실핼

JDK
자바 응용 개발 환경, 개발에 필요한 도구 포함
JRE
자바 실행 환경
개발자가 아닌경우 JRE만 따로 다운 가능

자바 API
JDK에 포함된 클래스 라이브러리 
주요한 기능들을 미리 구현한 클래스 라이브러리의 집합
API에서 정의한 규격에 따라 글래스 사용
자바 패키지 
서로 관련된 클래스들을 분류하여 묶어 놓은 것
	클래스의 이름에 패키지 이름도 포함
	다른 패키지의 동일한 이름의 클래스 존재 가능
자바 통합 개발 환경-이클립스
IDE
통합 개발 환경
편집,컴파일,디버깅을 한번에 할 수 있는 통합된 개발 환경

이클립스
자바 응용 프로그램 개발을 위한 통합 개발 환경
IBM에 의해 개발된 오픈 소스 프로젝트

자바 모바일 응용 : 안드로이드 앱

자바의 특징
플랫폼 독립성
객체지향-캡슐화,상속,다형성 지원
클래스의 캡슐화
자바의 모슨 변수나 함수는 클래스 내에 선언
클래스 안에서 클래스(내부 클래스) 작성 가능
소스(.java) 와 클래스 (.class) 파일
하나의 소스 파일에 여러 클래스를 작성 가능 - public 클래스는 하나만 가능
소스 파일의 이름과 public으로 선언된 클래스 이름은 같아야 함
클래스 파일에는 하나의 클래스만 존재- 다수의 클래스를 가진 자바 소스를 컴파일하면 클래스마다 별도 클래스 파일 생성
실행 코드-자바 응용프로그램의 실행은 main() 메소드에서 시작
패키지-서로 관련 있는 여러 클래스를 패키지로 묶어 관리
멀티스레드- 여러 스레드의 동시 수행 환경 지원
가비지 컬렉션-자바 언어는 메모리 할당 기능은 있어도 메모리 변환 기능 없음
실시간 응용프로그램에 부적합-실행 도중 예측할 수 없는 시점에 가비지 컬렉션 실행 때문
자바 프로그램은 안전-타입 체크 엄격,물리적 주소를 사용하는 포인터 개념 없음
프로그램 작성 쉬움-포인터 개념이 없음 ,동적 메모리 반환 하지 않음,다양한 라이브러리 지원
실행 속도 개선을 위한 JIT 컴파일러 사용 - 자바는 바이트 코드를 인터프리터 방식으로 실행,JIT 컴파일 기법으로 실행 속도 개선
식별자-클래스,변수,상수,메소드 등에 붙이는 이름
식별자의 원칙-특수 문자,공백,탭은 식별자 사용불가지만 "_", "$"는 사용가능
자바의 데이터 타입 
기본타입- boolean,char,byte,short,int,long,float,doubel
문자열-문자열은 기본 타입아님
문자열 이터럴 - "JDK","한글","계속하세요"
변수-변수값은 프로그램 수행 중 변경될 수 있음
변수 선언 - 데이터 타입에서 정한 크기의 메모리 할당
리터럴-프로그램에서 직접 표현한 값,정수,실수,문자,놀리 ,문자열 리터럴 있음
정수 리터럴-10진수,8진수,16진수,2진수 리터럴








## 3월 15일 강의
#### 내용정리
깃 유저네임, 이메일 등록

깃배쉬 익스텐션 깔기

이클립스를 이용하여 Hello.java 실습

수업에서는 vscode 사용 예정 - vscode에 자바 익스텐션 실치

hello.java와 test.java 파일 만들기 - 커밋과 푸쉬

##### 코드블럭 생성 및 주석 처리
 ```java
 public class Test {
	public static void main(String[] args) {
		System.out.println("Hello");
		//Hello를 출력
	}
}
```

## 3월 8일 강의
깃 아이디 생성 및 깃 레파지토리 만들기
